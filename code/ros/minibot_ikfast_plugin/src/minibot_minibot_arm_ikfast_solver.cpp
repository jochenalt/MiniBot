/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2020-06-14 21:36:15.991242
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57;
x0=IKcos(j[0]);
x1=IKsin(j[2]);
x2=IKsin(j[1]);
x3=IKcos(j[1]);
x4=IKcos(j[2]);
x5=IKsin(j[4]);
x6=IKsin(j[0]);
x7=IKsin(j[3]);
x8=IKcos(j[3]);
x9=IKcos(j[4]);
x10=IKsin(j[5]);
x11=IKcos(j[5]);
x12=((0.173649560788721)*x5);
x13=((0.731351161935082)*x4);
x14=((0.000112702600210493)*x1);
x15=((0.984807509129517)*x9);
x16=((0.682001083530082)*x0);
x17=((1.0)*x8);
x18=((0.731351161935082)*x0);
x19=((0.173649560788721)*x9);
x20=((0.682001083530082)*x6);
x21=((0.984807509129517)*x5);
x22=((0.731351161935082)*x6);
x23=(x0*x7);
x24=(x1*x2);
x25=(x1*x3);
x26=(x2*x4);
x27=(x5*x8);
x28=(x3*x4);
x29=(x8*x9);
x30=(x6*x7);
x31=((0.682001083530082)*x24);
x32=((0.682001083530082)*x26);
x33=(x0*x13*x3);
x34=(x13*x3*x6);
x35=((((0.731351161935082)*x25))+(((0.682001083530082)*x28))+((x13*x2)));
x36=((((0.731351161935082)*x24))+(((0.682001083530082)*x25))+x32+(((-1.0)*x13*x3)));
x37=((((-1.0)*x31))+x35);
x38=((((-1.0)*x35))+x31);
x39=(((x18*x24))+((x16*((x25+x26)))));
x40=(((x22*x24))+((x20*((x25+x26)))));
x41=(x37*x8);
x42=(x37*x7);
x43=(x38*x8);
x44=((((-1.0)*x39))+x33);
x45=((((-1.0)*x18*x25))+(((-1.0)*x0*x13*x2))+((x16*(((((-1.0)*x28))+x24)))));
x46=((((-1.0)*x40))+x34);
x47=((((-1.0)*x13*x2*x6))+((x20*(((((-1.0)*x28))+x24))))+(((-1.0)*x22*x25)));
x48=(x44*x8);
x49=(x46*x8);
x50=(((x7*(((((-1.0)*x33))+x39))))+(((-1.0)*x17*x6)));
x51=(((x0*x8))+((x7*(((((-1.0)*x34))+x40)))));
x52=(x49+x23);
x53=((((-1.0)*x30))+x48);
x54=((((-1.0)*x17*x44))+(((1.0)*x30)));
x55=(((x19*x36))+((x21*x36))+((x15*x43))+((x12*x41)));
x56=(((x12*x54))+((x19*x45))+((x15*x53))+((x21*x45)));
x57=(((x19*x47))+((x15*x52))+((x21*x47))+((x12*(((((-1.0)*x49))+(((-1.0)*x23)))))));
eerot[0]=(((x11*x56))+((x10*x50)));
eerot[1]=((((-1.0)*x10*x56))+((x11*x50)));
eerot[2]=((((-1.0)*x15*x45))+((x19*x53))+((x12*x45))+(((-1.0)*x21*x54)));
eetrans[0]=((((((((-0.000154101895336152)*(IKsin(j[0]))*(IKsin(j[3]))))+(((((((0.000112702600210493)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((-0.000105097659593295)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))+(((-0.000105097659593295)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((-0.000112702600210493)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((((((0.0902340191271345)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((-0.0902340191271345)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.096763416258988)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((0.096763416258988)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))))*(IKcos(j[4]))))+(((0.13162174)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))+(((0.13162174)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((0.104040710214349)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((((((0.023329615163818)*(((((-0.731351161935082)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.682001083530082)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))+(((-0.682001083530082)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((0.731351161935082)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))))*(IKcos(j[3]))))+(((-0.023329615163818)*(IKsin(j[0]))*(IKsin(j[3]))))))*(IKcos(j[4]))))+(((0.105175)*(IKcos(j[0]))*(IKsin(j[1]))))+(((((((-0.132307735729799)*(IKsin(j[0]))*(IKsin(j[3]))))+(((-0.132307735729799)*(((((0.731351161935082)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.731351161935082)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((0.682001083530082)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((0.682001083530082)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((((((-0.0170621411575566)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((-0.0159108228200637)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((-0.0170621411575566)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))+(((0.0159108228200637)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4]))))+(((((((2.71725450849634e-5)*(IKsin(j[0]))*(IKsin(j[3]))))+(((((((1.85317051902151e-5)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((1.85317051902151e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))+(((-1.98726724206214e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((1.98726724206214e-5)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[3]))))))*(IKsin(j[4]))))+(((-0.104040710214349)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((((((-1.98726724206214e-5)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((-1.85317051902151e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((-1.98726724206214e-5)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))+(((1.85317051902151e-5)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[4]))))+(((0.027362)*(IKcos(j[0]))*(IKcos(j[1]))))+(((((((0.000105097659593295)*(IKcos(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.000112702600210493)*(IKcos(j[0]))*(IKcos(j[2]))*(IKsin(j[1]))))+(((-0.000105097659593295)*(IKcos(j[0]))*(IKcos(j[1]))*(IKcos(j[2]))))+(((-0.000112702600210493)*(IKcos(j[0]))*(IKcos(j[1]))*(IKsin(j[2]))))))*(IKsin(j[4])))));
eerot[3]=(((x11*x57))+((x10*x51)));
eerot[4]=((((-1.0)*x10*x57))+((x11*x51)));
eerot[5]=((((-1.0)*x15*x47))+(((-1.0)*x21*(((((-1.0)*x23))+(((-1.0)*x17*x46))))))+((x19*x52))+((x12*x47)));
eetrans[1]=((((((((-1.85317051902151e-5)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))+(((1.85317051902151e-5)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-1.98726724206214e-5)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))+(((-1.98726724206214e-5)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((-0.104040710214349)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((((((-0.0902340191271345)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.096763416258988)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))+(((0.0902340191271345)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))+(((0.096763416258988)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKcos(j[4]))))+(((0.13162174)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((((((((((1.98726724206214e-5)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((1.85317051902151e-5)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-1.98726724206214e-5)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))+(((1.85317051902151e-5)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))+(((-2.71725450849634e-5)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((((((0.023329615163818)*(IKcos(j[0]))*(IKsin(j[3]))))+(((0.023329615163818)*(((((-0.682001083530082)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))+(((-0.731351161935082)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.682001083530082)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((0.731351161935082)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))))*(IKcos(j[3]))))))*(IKcos(j[4]))))+(((((((-0.132307735729799)*(((((0.682001083530082)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.731351161935082)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))+(((0.682001083530082)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))+(((0.731351161935082)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))))*(IKcos(j[3]))))+(((0.132307735729799)*(IKcos(j[0]))*(IKsin(j[3]))))))*(IKsin(j[4]))))+(((0.104040710214349)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))+(((((((-0.0159108228200637)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))+(((-0.0170621411575566)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))+(((0.0159108228200637)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.0170621411575566)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))))*(IKsin(j[4]))))+(((0.027362)*(IKcos(j[1]))*(IKsin(j[0]))))+(((0.13162174)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))+(((((((-0.000112702600210493)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.000112702600210493)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))+(((0.000105097659593295)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((-0.000105097659593295)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))))*(IKsin(j[4]))))+(((0.105175)*(IKsin(j[0]))*(IKsin(j[1]))))+(((((((0.000154101895336152)*(IKcos(j[0]))*(IKsin(j[3]))))+(((((((-0.000112702600210493)*(IKsin(j[0]))*(IKsin(j[1]))*(IKsin(j[2]))))+(((0.000112702600210493)*(IKcos(j[1]))*(IKcos(j[2]))*(IKsin(j[0]))))+(((-0.000105097659593295)*(IKcos(j[2]))*(IKsin(j[0]))*(IKsin(j[1]))))+(((-0.000105097659593295)*(IKcos(j[1]))*(IKsin(j[0]))*(IKsin(j[2]))))))*(IKcos(j[3]))))))*(IKcos(j[4])))));
eerot[6]=(((x10*x42))+((x11*x55)));
eerot[7]=((((-1.0)*x10*x55))+((x11*x42)));
eerot[8]=(((x19*x43))+(((-1.0)*x21*x41))+((x12*x36))+(((-1.0)*x15*x36)));
eetrans[2]=((0.175)+(((0.105175)*x3))+((x9*(((((-1.98726724206214e-5)*x28))+(((1.98726724206214e-5)*x24))+(((1.85317051902151e-5)*x25))+(((1.85317051902151e-5)*x26))))))+((x29*(((((-0.000112702600210493)*x26))+(((-1.0)*x14*x3))+(((-0.000105097659593295)*x28))+(((0.000105097659593295)*x24))))))+(((-0.104040710214349)*x26))+(((-0.104040710214349)*x25))+((x27*(((((1.98726724206214e-5)*x26))+(((1.98726724206214e-5)*x25))+(((-1.85317051902151e-5)*x24))+(((1.85317051902151e-5)*x28))))))+(((-0.13162174)*x24))+(((0.13162174)*x28))+(((-0.132307735729799)*x36*x9))+((x5*(((((-0.000112702600210493)*x28))+((x14*x2))+(((0.000105097659593295)*x25))+(((0.000105097659593295)*x26))))))+(((0.023329615163818)*x36*x5))+(((-0.132307735729799)*x27*x37))+(((0.023329615163818)*x29*x38))+(((-0.027362)*x2)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((((-0.134348829089196)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((((-0.134348829089196)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.175)+(((-0.134348829089196)*r22))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x58=((1.0)*px);
IkReal x59=((1.0)*pz);
IkReal x60=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x60))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x59)));
rxp0_2=((((-1.0)*r10*x58))+((py*r00)));
rxp1_0=((((-1.0)*r21*x60))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x59)));
rxp1_2=((((-1.0)*r11*x58))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x60)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x59)));
rxp2_2=((((-1.0)*r12*x58))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x61=((0.173649560788721)*rxp0_2);
IkReal x62=((0.984807509129517)*rxp2_2);
IkReal x63=((0.000154101895336152)*r21);
IkReal x64=((0.0142019131584533)*rxp0_1);
IkReal x65=((1.26032091597392e-5)*r11);
IkReal x66=((2.99011605925456)*pp);
IkReal x67=((0.0805423904265847)*rxp2_1);
IkReal x68=((0.17271377882578)*npx);
IkReal x69=((0.984807509129517)*npz);
IkReal x70=((0.0142019131584533)*rxp0_0);
IkReal x71=((1.26032091597392e-5)*r01);
IkReal x72=((0.0805423904265847)*rxp2_0);
IkReal x73=((2.52064183194784e-5)*r10);
IkReal x74=((0.34542755765156)*npy);
IkReal x75=((0.0284038263169067)*rxp1_1);
IkReal x76=((1.96961501825903)*rxp0_2);
IkReal x77=((5.43450901699269e-5)*r21);
IkReal x78=((0.347299121577443)*rxp2_2);
IkReal x79=((0.161084780853169)*rxp0_1);
IkReal x80=((0.347299121577443)*npz);
IkReal x81=((0.0284038263169067)*rxp2_1);
IkReal x82=((4.44460813880588e-6)*r11);
IkReal x83=((1.96961501825903)*npx);
IkReal x84=((0.0284038263169067)*rxp2_0);
IkReal x85=((4.44460813880588e-6)*r01);
IkReal x86=((0.161084780853169)*rxp0_0);
IkReal x87=((3.93923003651807)*npy);
IkReal x88=((0.322169561706339)*rxp1_1);
IkReal x89=((8.88921627761176e-6)*r10);
IkReal x90=((0.000308203790672304)*r20);
IkReal x91=((0.347299121577443)*rxp1_2);
IkReal x92=((0.0284038263169067)*rxp1_0);
IkReal x93=((2.52064183194784e-5)*r00);
IkReal x94=((0.174585342751662)*npx);
IkReal x95=((0.349170685503325)*npy);
IkReal x96=(x91+(((-1.0)*x90)));
IkReal x97=(x93+(((-1.0)*x92)));
IkReal x98=(x90+(((-1.0)*x91)));
IkReal x99=(x92+(((-1.0)*x93)));
IkReal x100=((0.0488262904191973)+x66);
IkReal x101=((0.0488806355093672)+x66);
IkReal x102=((-0.000308203790672304)+x80);
IkReal x103=((((0.000108690180339854)*r20))+(((3.93923003651807)*rxp1_2)));
IkReal x104=((((-0.322169561706339)*rxp1_0))+(((-8.88921627761176e-6)*r00)));
IkReal x105=(x61+x63);
IkReal x106=(x71+x70);
IkReal x107=(x64+x65);
IkReal x108=(x68+x69);
IkReal x109=(x79+x83);
IkReal x110=(x88+x89);
IkReal x111=(x67+x94);
IkReal x112=(x67+x69);
IkReal x113=(x82+x83);
IkReal x114=((((-1.0)*x105))+x62);
IkReal x115=((((-1.0)*x72))+x106);
IkReal x116=((((-1.0)*x76))+(((-1.0)*x78))+x77);
IkReal x117=((((-1.0)*x77))+(((-1.0)*x78))+x76);
IkReal x118=(x86+x84+(((-1.0)*x85)));
IkReal x119=(x84+x85+(((-1.0)*x86)));
IkReal x120=(x105+(((-1.0)*x62)));
IkReal x121=((((-1.0)*x106))+x72);
IkReal x122=(x102+x81);
IkReal x123=(x105+x62);
IkReal x124=((((-1.0)*x72))+(((-1.0)*x106)));
IkReal x125=((-1.0)*x123);
IkReal x126=(x106+x72);
op[0]=x114;
op[1]=x114;
op[2]=x96;
op[3]=x96;
op[4]=x123;
op[5]=x123;
op[6]=((((-1.0)*x107))+x100+x67+x68+(((-1.0)*x69)));
op[7]=x115;
op[8]=((((-1.0)*x73))+(((-1.0)*x74))+x75);
op[9]=x97;
op[10]=((((-1.0)*x108))+x107+x100+x67);
op[11]=x124;
op[12]=x115;
op[13]=((((-1.0)*x112))+x107+x100+x68);
op[14]=x97;
op[15]=((((-1.0)*x74))+(((-1.0)*x75))+x73);
op[16]=x124;
op[17]=((((-1.0)*x108))+(((-1.0)*x107))+x100+(((-1.0)*x67)));
op[18]=0;
op[19]=x114;
op[20]=0;
op[21]=x96;
op[22]=0;
op[23]=x123;
op[24]=x116;
op[25]=x116;
op[26]=x103;
op[27]=x103;
op[28]=x117;
op[29]=x117;
op[30]=((((-1.0)*x79))+x113+x102+(((-1.0)*x81)));
op[31]=x118;
op[32]=(x110+(((-1.0)*x87)));
op[33]=x104;
op[34]=((((-1.0)*x113))+x102+x79+(((-1.0)*x81)));
op[35]=x119;
op[36]=x118;
op[37]=(x122+x109+(((-1.0)*x82)));
op[38]=x104;
op[39]=((((-1.0)*x110))+(((-1.0)*x87)));
op[40]=x119;
op[41]=((((-1.0)*x109))+x122+x82);
op[42]=0;
op[43]=x116;
op[44]=0;
op[45]=x103;
op[46]=0;
op[47]=x117;
op[48]=x120;
op[49]=x120;
op[50]=x98;
op[51]=x98;
op[52]=x125;
op[53]=x125;
op[54]=((((-1.0)*x111))+x107+x101+x69);
op[55]=x121;
op[56]=((((-1.0)*x75))+x73+x95);
op[57]=x99;
op[58]=((((-1.0)*x107))+x101+x69+x94+(((-1.0)*x67)));
op[59]=x126;
op[60]=x121;
op[61]=((((-1.0)*x107))+x112+x101+(((-1.0)*x94)));
op[62]=x99;
op[63]=((((-1.0)*x73))+x75+x95);
op[64]=x126;
op[65]=(x111+x107+x101+x69);
op[66]=0;
op[67]=x120;
op[68]=0;
op[69]=x98;
op[70]=0;
op[71]=x125;
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x127=htj4*htj4;
CheckValue<IkReal> x128=IKPowWithIntegerCheck(((1.0)+x127),-1);
if(!x128.valid){
continue;
}
cj4array[numsolutions]=((x128.value)*(((1.0)+(((-1.0)*x127)))));
CheckValue<IkReal> x129=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x129.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x129.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x130=htj5*htj5;
CheckValue<IkReal> x131=IKPowWithIntegerCheck(((1.0)+x130),-1);
if(!x131.valid){
continue;
}
cj5array[numsolutions]=((x131.value)*(((1.0)+(((-1.0)*x130)))));
CheckValue<IkReal> x132=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x132.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x132.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x133=htj0*htj0;
CheckValue<IkReal> x134=IKPowWithIntegerCheck(((1.0)+x133),-1);
if(!x134.valid){
continue;
}
cj0array[numsolutions]=((x134.value)*(((1.0)+(((-1.0)*x133)))));
CheckValue<IkReal> x135=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x135.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x135.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[2];
IkReal x136=(cj5*r00);
IkReal x137=((0.173649560788721)*cj4);
IkReal x138=(cj4*r02);
IkReal x139=(r01*sj5);
IkReal x140=((0.984807509129517)*sj4);
IkReal x141=((5.6712352433055)*sj4);
IkReal x142=(r02*sj4);
j3eval[0]=((((-1.0)*cj4*x139))+((x136*x141))+(((-1.0)*x139*x141))+x142+(((-5.6712352433055)*x138))+((cj4*x136)));
j3eval[1]=IKsign((((x136*x140))+(((-1.0)*x137*x139))+(((0.173649560788721)*x142))+((x136*x137))+(((-1.0)*x139*x140))+(((-0.984807509129517)*x138))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x143=(cj5*r10);
IkReal x144=((0.984807509129517)*sj4);
IkReal x145=(r12*sj4);
IkReal x146=((5.6712352433055)*sj4);
IkReal x147=(r11*sj5);
IkReal x148=(cj4*r12);
IkReal x149=(cj4*x147);
j3eval[0]=((((-5.6712352433055)*x148))+x145+(((-1.0)*x149))+(((-1.0)*x146*x147))+((cj4*x143))+((x143*x146)));
j3eval[1]=IKsign(((((-0.984807509129517)*x148))+(((-0.173649560788721)*x149))+(((-1.0)*x144*x147))+(((0.173649560788721)*cj4*x143))+(((0.173649560788721)*x145))+((x143*x144))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x150=(r21*sj5);
IkReal x151=(r22*sj4);
IkReal x152=(cj4*r22);
IkReal x153=((0.984807509129517)*sj4);
IkReal x154=(cj5*r20);
IkReal x155=((5.6712352433055)*sj4);
IkReal x156=((0.173649560788721)*cj4);
j3eval[0]=(((cj4*x150))+(((-1.0)*x154*x155))+(((-1.0)*cj4*x154))+((x150*x155))+(((-1.0)*x151))+(((5.6712352433055)*x152)));
j3eval[1]=IKsign(((((-1.0)*x154*x156))+(((-1.0)*x153*x154))+(((0.984807509129517)*x152))+((x150*x153))+((x150*x156))+(((-0.173649560788721)*x151))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x157=(sj0*sj5);
IkReal x158=(cj4*sj0);
IkReal x159=((0.984807509129517)*cj4);
IkReal x160=((0.173649560788721)*sj4);
IkReal x161=((0.984807509129517)*sj4);
IkReal x162=(cj0*r02);
IkReal x163=(cj5*r10);
IkReal x164=((1.0)*cj0);
IkReal x165=((0.173649560788721)*cj4);
IkReal x166=(cj0*cj5*r00);
IkReal x167=(cj0*r01*sj5);
CheckValue<IkReal> x168 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r01*x164))+(((-1.0)*cj5*r11*sj0))+(((-1.0)*r00*sj5*x164))+(((-1.0)*r10*x157)))),IkReal((((x161*x162))+(((0.173649560788721)*r12*x158))+((r11*x157*x160))+(((-1.0)*x159*x167))+(((-1.0)*x160*x166))+(((-1.0)*r11*x157*x159))+((x162*x165))+(((0.984807509129517)*x158*x163))+((r12*sj0*x161))+(((-1.0)*sj0*x160*x163))+((x159*x166))+((x160*x167)))),IKFAST_ATAN2_MAGTHRESH);
if(!x168.valid){
continue;
}
CheckValue<IkReal> x169=IKPowWithIntegerCheck(IKsign((((r20*(((((-1.0)*cj5*x165))+(((-1.0)*cj5*x161))))))+((r21*((((sj5*x161))+((sj5*x165))))))+((r22*(((((-1.0)*x160))+x159)))))),-1);
if(!x169.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x168.value)+(((1.5707963267949)*(x169.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x170=IKsin(j3);
IkReal x171=IKcos(j3);
IkReal x172=((0.173649560788721)*sj4);
IkReal x173=((0.984807509129517)*cj4);
IkReal x174=(cj5*x170);
IkReal x175=(sj5*x170);
IkReal x176=((1.0)*x171);
IkReal x177=((0.984807509129517)*sj4*x170);
IkReal x178=((0.173649560788721)*cj4*x170);
evalcond[0]=((((-1.0)*r20*sj5*x176))+((r21*x173*x175))+(((-1.0)*r22*x178))+(((-1.0)*r22*x177))+(((-1.0)*cj5*r21*x176))+(((-1.0)*r21*x172*x175))+(((-1.0)*r20*x173*x174))+((r20*x172*x174)));
evalcond[1]=((((-1.0)*r11*x172*x175))+cj0+(((-1.0)*r10*x173*x174))+((r10*x172*x174))+((r11*x173*x175))+(((-1.0)*cj5*r11*x176))+(((-1.0)*r10*sj5*x176))+(((-1.0)*r12*x177))+(((-1.0)*r12*x178)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r02*x178))+(((-1.0)*r02*x177))+(((-1.0)*r00*x173*x174))+((r01*x173*x175))+(((-1.0)*r01*x172*x175))+(((-1.0)*cj5*r01*x176))+((r00*x172*x174))+(((-1.0)*r00*sj5*x176)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x179=((0.0688516427711342)*cj0);
IkReal x180=((0.164110499907597)*px);
IkReal x181=((0.0481101427077374)*cj0);
IkReal x182=((0.0547034999691992)*px);
IkReal x183=(cj0*pz);
IkReal x184=(r01*sj5);
IkReal x185=((0.110884408669817)*cj0);
IkReal x186=(cj4*r22);
IkReal x187=(cj5*r00);
IkReal x188=((0.332653226009452)*cj0);
IkReal x189=(r21*sj5);
IkReal x190=(cj0*cj4);
IkReal x191=((0.000313992904188461)*cj0);
IkReal x192=(cj5*r20);
IkReal x193=((0.000104664301396154)*cj0);
IkReal x194=((2.56798804293015e-5)*x187);
IkReal x195=((2.00661107498811)*x183);
IkReal x196=((2.56798804293015e-5)*x184);
IkReal x197=((0.668870358329369)*x183);
IkReal x198=((8.55996014310049e-6)*x187);
IkReal x199=((8.55996014310049e-6)*x184);
IkReal x200=(sj4*x192);
IkReal x201=(cj0*r22*sj4);
IkReal x202=(x189*x191);
IkReal x203=((0.0586562206888043)*x201);
IkReal x204=(x186*x188);
IkReal x205=(x191*x192);
IkReal x206=(x189*x193);
IkReal x207=((0.0195520735629348)*x201);
IkReal x208=(x192*x193);
IkReal x209=(x185*x186);
IkReal x210=(x190*x192);
IkReal x211=((3.30872245021211e-24)*(x189*x189));
IkReal x212=((3.30872245021211e-24)*(x192*x192));
IkReal x213=(x188*x200);
IkReal x214=((0.0586562206888043)*x210);
IkReal x215=(sj4*x188*x189);
IkReal x216=((0.0586562206888043)*x189*x190);
IkReal x217=((0.0195520735629348)*x210);
IkReal x218=(x185*x200);
IkReal x219=((0.0195520735629348)*x189*x190);
IkReal x220=(sj4*x185*x189);
IkReal x221=(x179+x211+x212);
IkReal x222=(x199+x182+x219+x220+x209+x208);
IkReal x223=(x196+x180+x215+x216+x205+x204);
IkReal x224=(x198+x197+x217+x218+x207+x206);
IkReal x225=(x195+x194+x213+x214+x203+x202);
op[0]=(x221+x224+(((-1.0)*x222)));
op[1]=x181;
op[2]=(x221+x225+(((-1.0)*x223)));
op[3]=((0.0962202854154749)*cj0);
op[4]=(x225+(((-1.0)*x223))+(((-1.0)*x221)));
op[5]=x181;
op[6]=(x224+(((-1.0)*x221))+(((-1.0)*x222)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x226=((0.0688516427711342)*sj0);
IkReal x227=((0.164110499907597)*py);
IkReal x228=((0.0547034999691992)*py);
IkReal x229=(sj0*sj4);
IkReal x230=(cj5*r20);
IkReal x231=(r21*sj5);
IkReal x232=((0.000313992904188461)*sj0);
IkReal x233=(cj4*sj0);
IkReal x234=((0.000104664301396154)*sj0);
IkReal x235=(r11*sj5);
IkReal x236=(pz*sj0);
IkReal x237=((0.0481101427077374)*sj0);
IkReal x238=(cj5*r10);
IkReal x239=((2.56798804293015e-5)*x238);
IkReal x240=((2.00661107498811)*x236);
IkReal x241=((2.56798804293015e-5)*x235);
IkReal x242=((0.668870358329369)*x236);
IkReal x243=((8.55996014310049e-6)*x238);
IkReal x244=((8.55996014310049e-6)*x235);
IkReal x245=((0.0586562206888043)*x233);
IkReal x246=((0.0586562206888043)*r22*x229);
IkReal x247=(x231*x232);
IkReal x248=(x230*x232);
IkReal x249=((0.332653226009452)*r22*x233);
IkReal x250=((0.0195520735629348)*r22*x229);
IkReal x251=(x231*x234);
IkReal x252=(x230*x234);
IkReal x253=((0.110884408669817)*r22*x233);
IkReal x254=((3.30872245021211e-24)*(x231*x231));
IkReal x255=(x230*x245);
IkReal x256=((3.30872245021211e-24)*(x230*x230));
IkReal x257=((0.332653226009452)*x229*x230);
IkReal x258=((0.332653226009452)*x229*x231);
IkReal x259=(x231*x245);
IkReal x260=((0.110884408669817)*x229*x230);
IkReal x261=((0.0195520735629348)*x230*x233);
IkReal x262=((0.0195520735629348)*x231*x233);
IkReal x263=((0.110884408669817)*x229*x231);
IkReal x264=(x254+x256+x226);
IkReal x265=(x258+x259+x227+x241+x249+x248);
IkReal x266=(x252+x253+x228+x263+x262+x244);
IkReal x267=(x250+x251+x261+x260+x243+x242);
IkReal x268=(x255+x257+x239+x240+x247+x246);
j1evalpoly[0]=((((htj1*htj1*htj1*htj1*htj1*htj1)*((x264+x267+(((-1.0)*x266))))))+((htj1*x237))+((x237*(htj1*htj1*htj1*htj1*htj1)))+x267+(((0.0962202854154749)*sj0*(htj1*htj1*htj1)))+(((-1.0)*x264))+(((-1.0)*x266))+(((htj1*htj1*htj1*htj1)*((x264+x268+(((-1.0)*x265))))))+(((htj1*htj1)*((x268+(((-1.0)*x264))+(((-1.0)*x265)))))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x269=cj1*cj1;
IkReal x270=(r21*sj5);
IkReal x271=((0.0083681115751417)*sj1);
IkReal x272=(cj5*r20);
IkReal x273=((7.49203050861088)*sj1);
IkReal x274=((0.0083681115751417)*cj1);
IkReal x275=(cj4*r22);
IkReal x276=((9.47815609529019)*sj4);
IkReal x277=((49.8689176315288)*pz);
IkReal x278=((0.00780344854617712)*sj1);
IkReal x279=((0.00780344854617712)*cj1);
IkReal x280=(cj1*sj1);
IkReal x281=((7.49203050861088)*cj1);
IkReal x282=((53.4774676097046)*pz);
IkReal x283=((1.67126837252581)*cj4*sj1);
IkReal x284=((1.32105796835966)*r22*sj4);
IkReal x285=((1.67126837252581)*cj1*cj4);
IkReal x286=((1.32105796835966)*cj4*sj1);
IkReal x287=((1.67126837252581)*r22*sj4);
IkReal x288=((1.32105796835966)*cj1*cj4);
if( IKabs(((-1.36451332423389)+((x272*x278))+((x273*x275))+(((-1.0)*x272*x274))+(((-1.0)*x270*x285))+(((-1.0)*sj1*x284))+(((-1.0)*sj1*x277))+((sj4*x270*x273))+(((-1.0)*sj4*x272*x273))+(((6.70821388063278)*x280))+((x270*x274))+((x272*x285))+((cj1*x272*x276))+(((-4.25997933161679)*x269))+(((-1.0)*x270*x278))+(((-1.0)*x272*x286))+((cj1*x287))+((cj1*x282))+(((-9.47815609529019)*cj1*x275))+(((-1.0)*cj1*x270*x276))+((x270*x286)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.46325046873674)+(((-1.0)*x272*x279))+(((-1.0)*x270*x288))+(((-1.0)*x270*x283))+(((-1.0)*sj1*x270*x276))+((sj1*x272*x276))+(((-9.47815609529019)*sj1*x275))+(((-1.0)*x271*x272))+(((-6.70821388063278)*x269))+((cj1*x277))+((x270*x279))+((x270*x271))+((sj4*x272*x281))+((x272*x283))+((x272*x288))+(((-1.0)*sj4*x270*x281))+((cj1*x284))+((sj1*x282))+((sj1*x287))+(((-1.0)*x275*x281))+(((-4.2599793316168)*x280)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.36451332423389)+((x272*x278))+((x273*x275))+(((-1.0)*x272*x274))+(((-1.0)*x270*x285))+(((-1.0)*sj1*x284))+(((-1.0)*sj1*x277))+((sj4*x270*x273))+(((-1.0)*sj4*x272*x273))+(((6.70821388063278)*x280))+((x270*x274))+((x272*x285))+((cj1*x272*x276))+(((-4.25997933161679)*x269))+(((-1.0)*x270*x278))+(((-1.0)*x272*x286))+((cj1*x287))+((cj1*x282))+(((-9.47815609529019)*cj1*x275))+(((-1.0)*cj1*x270*x276))+((x270*x286))))+IKsqr(((1.46325046873674)+(((-1.0)*x272*x279))+(((-1.0)*x270*x288))+(((-1.0)*x270*x283))+(((-1.0)*sj1*x270*x276))+((sj1*x272*x276))+(((-9.47815609529019)*sj1*x275))+(((-1.0)*x271*x272))+(((-6.70821388063278)*x269))+((cj1*x277))+((x270*x279))+((x270*x271))+((sj4*x272*x281))+((x272*x283))+((x272*x288))+(((-1.0)*sj4*x270*x281))+((cj1*x284))+((sj1*x282))+((sj1*x287))+(((-1.0)*x275*x281))+(((-4.2599793316168)*x280))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.36451332423389)+((x272*x278))+((x273*x275))+(((-1.0)*x272*x274))+(((-1.0)*x270*x285))+(((-1.0)*sj1*x284))+(((-1.0)*sj1*x277))+((sj4*x270*x273))+(((-1.0)*sj4*x272*x273))+(((6.70821388063278)*x280))+((x270*x274))+((x272*x285))+((cj1*x272*x276))+(((-4.25997933161679)*x269))+(((-1.0)*x270*x278))+(((-1.0)*x272*x286))+((cj1*x287))+((cj1*x282))+(((-9.47815609529019)*cj1*x275))+(((-1.0)*cj1*x270*x276))+((x270*x286))), ((1.46325046873674)+(((-1.0)*x272*x279))+(((-1.0)*x270*x288))+(((-1.0)*x270*x283))+(((-1.0)*sj1*x270*x276))+((sj1*x272*x276))+(((-9.47815609529019)*sj1*x275))+(((-1.0)*x271*x272))+(((-6.70821388063278)*x269))+((cj1*x277))+((x270*x279))+((x270*x271))+((sj4*x272*x281))+((x272*x283))+((x272*x288))+(((-1.0)*sj4*x270*x281))+((cj1*x284))+((sj1*x282))+((sj1*x287))+(((-1.0)*x275*x281))+(((-4.2599793316168)*x280))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x289=IKsin(j2);
IkReal x290=IKcos(j2);
IkReal x291=(cj5*r00);
IkReal x292=((0.984807509129517)*sj4);
IkReal x293=(sj0*sj1);
IkReal x294=((0.173649560788721)*cj4);
IkReal x295=(r11*sj5);
IkReal x296=(cj5*sj3);
IkReal x297=((0.984807509129517)*cj4);
IkReal x298=((0.682001083530082)*cj1);
IkReal x299=(r21*sj5);
IkReal x300=((0.173649560788721)*sj4);
IkReal x301=(r01*sj5);
IkReal x302=(cj0*sj1);
IkReal x303=(cj5*r10);
IkReal x304=((0.731351161935082)*cj1);
IkReal x305=(cj3*r02);
IkReal x306=(sj3*sj5);
IkReal x307=(cj3*r12);
IkReal x308=(cj5*r20);
IkReal x309=(cj3*r22);
IkReal x310=((0.027362)*cj1);
IkReal x311=((0.104040710214349)*cj1);
IkReal x312=((0.13162174)*x290);
IkReal x313=(cj3*x308);
IkReal x314=(sj0*x289);
IkReal x315=((0.731351161935082)*x289);
IkReal x316=(cj0*x290);
IkReal x317=((0.682001083530082)*x289);
IkReal x318=(sj0*x290);
IkReal x319=(sj1*x290);
IkReal x320=((0.731351161935082)*x290);
IkReal x321=((0.104040710214349)*x289);
IkReal x322=((0.682001083530082)*x290);
IkReal x323=(cj0*cj1*x289);
evalcond[0]=((((-0.13162174)*sj1*x289))+(((0.105175)*cj1))+((cj1*x312))+(((0.000156479204217649)*x308))+(((-1.0)*pz))+(((-0.027362)*sj1))+(((-0.000156479204217649)*x299))+(((-1.0)*x289*x311))+(((-0.104040710214349)*x319)));
evalcond[1]=(((x302*x312))+(((0.13162174)*x323))+(((0.105175)*x302))+(((-1.0)*px))+((x311*x316))+(((0.000156479204217649)*x291))+((cj0*x310))+(((-0.000156479204217649)*x301))+(((-1.0)*x302*x321)));
evalcond[2]=(((x293*x312))+((sj0*x310))+(((0.000156479204217649)*x303))+(((-1.0)*x293*x321))+(((-1.0)*py))+(((0.13162174)*cj1*x314))+((x311*x318))+(((0.105175)*x293))+(((-0.000156479204217649)*x295)));
evalcond[3]=((((-0.682001083530082)*x319))+((r22*x300))+((x290*x304))+(((-1.0)*x289*x298))+(((-1.0)*sj1*x315))+((x292*x308))+((x294*x308))+(((-1.0)*r22*x297))+(((-1.0)*x294*x299))+(((-1.0)*x292*x299)));
evalcond[4]=(((x291*x292))+((x291*x294))+(((-1.0)*x292*x301))+(((-1.0)*x294*x301))+((x302*x320))+(((-1.0)*x302*x317))+((x298*x316))+((r02*x300))+(((-1.0)*r02*x297))+((cj0*x289*x304)));
evalcond[5]=(((x304*x314))+((x292*x303))+((x298*x318))+((x294*x303))+(((-1.0)*x293*x317))+((x293*x320))+(((-1.0)*r12*x297))+(((-1.0)*x294*x295))+((r12*x300))+(((-1.0)*x292*x295)));
evalcond[6]=((((-1.0)*x292*x309))+(((-1.0)*x290*x298))+(((-1.0)*x297*x313))+((x300*x313))+(((-1.0)*x294*x309))+((sj1*x317))+(((-0.731351161935082)*x319))+((r20*x306))+(((-1.0)*x289*x304))+((r21*x296))+((cj3*x297*x299))+(((-1.0)*cj3*x299*x300)));
evalcond[7]=(((x304*x316))+(((-1.0)*x292*x305))+(((-1.0)*x294*x305))+(((-1.0)*cj3*x300*x301))+((cj3*x291*x300))+(((-1.0)*x302*x315))+((cj3*x297*x301))+((r01*x296))+(((-1.0)*cj3*x291*x297))+((r00*x306))+(((-1.0)*cj0*x289*x298))+(((-1.0)*x302*x322)));
evalcond[8]=(((x304*x318))+(((-1.0)*x292*x307))+((cj3*x295*x297))+(((-1.0)*x294*x307))+(((-1.0)*x293*x322))+(((-1.0)*cj3*x295*x300))+(((-1.0)*x293*x315))+((r10*x306))+(((-1.0)*cj3*x297*x303))+(((-1.0)*x298*x314))+((cj3*x300*x303))+((r11*x296)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x324=((0.984807509129517)*sj4);
IkReal x325=(r22*sj0);
IkReal x326=((0.173649560788721)*sj5);
IkReal x327=(r21*sj0);
IkReal x328=((0.173649560788721)*cj4);
IkReal x329=((0.984807509129517)*cj4);
IkReal x330=(r20*sj0);
IkReal x331=((0.173649560788721)*sj4);
CheckValue<IkReal> x332 = IKatan2WithCheck(IkReal(((((-1.0)*sj5*x330))+(((-1.0)*cj5*x327)))),IkReal((((x325*x328))+(((-1.0)*cj5*x330*x331))+((x324*x325))+((cj5*x329*x330))+(((-1.0)*sj5*x327*x329))+((sj4*x326*x327)))),IKFAST_ATAN2_MAGTHRESH);
if(!x332.valid){
continue;
}
CheckValue<IkReal> x333=IKPowWithIntegerCheck(IKsign((((r10*((((cj5*x328))+((cj5*x324))))))+((r12*(((((-1.0)*x329))+x331))))+((r11*(((((-1.0)*cj4*x326))+(((-1.0)*sj5*x324)))))))),-1);
if(!x333.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x332.value)+(((1.5707963267949)*(x333.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x334=IKsin(j3);
IkReal x335=IKcos(j3);
IkReal x336=((0.173649560788721)*sj4);
IkReal x337=((0.984807509129517)*cj4);
IkReal x338=(cj5*x334);
IkReal x339=(sj5*x334);
IkReal x340=((1.0)*x335);
IkReal x341=((0.984807509129517)*sj4*x334);
IkReal x342=((0.173649560788721)*cj4*x334);
evalcond[0]=((((-1.0)*r22*x342))+(((-1.0)*r22*x341))+(((-1.0)*r21*x336*x339))+(((-1.0)*r20*sj5*x340))+((r20*x336*x338))+(((-1.0)*r20*x337*x338))+((r21*x337*x339))+(((-1.0)*cj5*r21*x340)));
evalcond[1]=((((-1.0)*cj5*r11*x340))+(((-1.0)*r12*x342))+(((-1.0)*r12*x341))+cj0+((r10*x336*x338))+(((-1.0)*r11*x336*x339))+((r11*x337*x339))+(((-1.0)*r10*sj5*x340))+(((-1.0)*r10*x337*x338)));
evalcond[2]=((((-1.0)*r02*x341))+(((-1.0)*r02*x342))+(((-1.0)*r00*x337*x338))+(((-1.0)*sj0))+((r00*x336*x338))+(((-1.0)*cj5*r01*x340))+(((-1.0)*r01*x336*x339))+(((-1.0)*r00*sj5*x340))+((r01*x337*x339)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x343=((0.0688516427711342)*cj0);
IkReal x344=((0.164110499907597)*px);
IkReal x345=((0.0481101427077374)*cj0);
IkReal x346=((0.0547034999691992)*px);
IkReal x347=(cj0*pz);
IkReal x348=(r01*sj5);
IkReal x349=((0.110884408669817)*cj0);
IkReal x350=(cj4*r22);
IkReal x351=(cj5*r00);
IkReal x352=((0.332653226009452)*cj0);
IkReal x353=(r21*sj5);
IkReal x354=(cj0*cj4);
IkReal x355=((0.000313992904188461)*cj0);
IkReal x356=(cj5*r20);
IkReal x357=((0.000104664301396154)*cj0);
IkReal x358=((2.56798804293015e-5)*x351);
IkReal x359=((2.00661107498811)*x347);
IkReal x360=((2.56798804293015e-5)*x348);
IkReal x361=((0.668870358329369)*x347);
IkReal x362=((8.55996014310049e-6)*x351);
IkReal x363=((8.55996014310049e-6)*x348);
IkReal x364=(sj4*x356);
IkReal x365=(cj0*r22*sj4);
IkReal x366=(x353*x355);
IkReal x367=((0.0586562206888043)*x365);
IkReal x368=(x350*x352);
IkReal x369=(x355*x356);
IkReal x370=(x353*x357);
IkReal x371=((0.0195520735629348)*x365);
IkReal x372=(x356*x357);
IkReal x373=(x349*x350);
IkReal x374=(x354*x356);
IkReal x375=((3.30872245021211e-24)*(x353*x353));
IkReal x376=((3.30872245021211e-24)*(x356*x356));
IkReal x377=(x352*x364);
IkReal x378=((0.0586562206888043)*x374);
IkReal x379=(sj4*x352*x353);
IkReal x380=((0.0586562206888043)*x353*x354);
IkReal x381=((0.0195520735629348)*x374);
IkReal x382=(x349*x364);
IkReal x383=((0.0195520735629348)*x353*x354);
IkReal x384=(sj4*x349*x353);
IkReal x385=(x343+x376+x375);
IkReal x386=(x384+x383+x346+x373+x372+x363);
IkReal x387=(x380+x344+x379+x368+x369+x360);
IkReal x388=(x382+x381+x371+x370+x361+x362);
IkReal x389=(x359+x358+x378+x377+x366+x367);
op[0]=(x385+x388+(((-1.0)*x386)));
op[1]=x345;
op[2]=(x385+x389+(((-1.0)*x387)));
op[3]=((0.0962202854154749)*cj0);
op[4]=(x389+(((-1.0)*x385))+(((-1.0)*x387)));
op[5]=x345;
op[6]=(x388+(((-1.0)*x385))+(((-1.0)*x386)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x390=((0.0688516427711342)*sj0);
IkReal x391=((0.164110499907597)*py);
IkReal x392=((0.0547034999691992)*py);
IkReal x393=(sj0*sj4);
IkReal x394=(cj5*r20);
IkReal x395=(r21*sj5);
IkReal x396=((0.000313992904188461)*sj0);
IkReal x397=(cj4*sj0);
IkReal x398=((0.000104664301396154)*sj0);
IkReal x399=(r11*sj5);
IkReal x400=(pz*sj0);
IkReal x401=((0.0481101427077374)*sj0);
IkReal x402=(cj5*r10);
IkReal x403=((2.56798804293015e-5)*x402);
IkReal x404=((2.00661107498811)*x400);
IkReal x405=((2.56798804293015e-5)*x399);
IkReal x406=((0.668870358329369)*x400);
IkReal x407=((8.55996014310049e-6)*x402);
IkReal x408=((8.55996014310049e-6)*x399);
IkReal x409=((0.0586562206888043)*x397);
IkReal x410=((0.0586562206888043)*r22*x393);
IkReal x411=(x395*x396);
IkReal x412=(x394*x396);
IkReal x413=((0.332653226009452)*r22*x397);
IkReal x414=((0.0195520735629348)*r22*x393);
IkReal x415=(x395*x398);
IkReal x416=(x394*x398);
IkReal x417=((0.110884408669817)*r22*x397);
IkReal x418=((3.30872245021211e-24)*(x395*x395));
IkReal x419=(x394*x409);
IkReal x420=((3.30872245021211e-24)*(x394*x394));
IkReal x421=((0.332653226009452)*x393*x394);
IkReal x422=((0.332653226009452)*x393*x395);
IkReal x423=(x395*x409);
IkReal x424=((0.110884408669817)*x393*x394);
IkReal x425=((0.0195520735629348)*x394*x397);
IkReal x426=((0.0195520735629348)*x395*x397);
IkReal x427=((0.110884408669817)*x393*x395);
IkReal x428=(x390+x418+x420);
IkReal x429=(x391+x405+x412+x413+x423+x422);
IkReal x430=(x392+x408+x416+x417+x427+x426);
IkReal x431=(x407+x406+x414+x415+x425+x424);
IkReal x432=(x403+x404+x410+x411+x419+x421);
j1evalpoly[0]=((((htj1*htj1*htj1*htj1)*(((((-1.0)*x429))+x428+x432))))+(((-1.0)*x430))+((htj1*x401))+(((-1.0)*x428))+(((htj1*htj1)*(((((-1.0)*x428))+(((-1.0)*x429))+x432))))+x431+((x401*(htj1*htj1*htj1*htj1*htj1)))+(((0.0962202854154749)*sj0*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x430))+x428+x431)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x433=cj1*cj1;
IkReal x434=(r21*sj5);
IkReal x435=((0.0083681115751417)*sj1);
IkReal x436=(cj5*r20);
IkReal x437=((7.49203050861088)*sj1);
IkReal x438=((0.0083681115751417)*cj1);
IkReal x439=(cj4*r22);
IkReal x440=((9.47815609529019)*sj4);
IkReal x441=((49.8689176315288)*pz);
IkReal x442=((0.00780344854617712)*sj1);
IkReal x443=((0.00780344854617712)*cj1);
IkReal x444=(cj1*sj1);
IkReal x445=((7.49203050861088)*cj1);
IkReal x446=((53.4774676097046)*pz);
IkReal x447=((1.67126837252581)*cj4*sj1);
IkReal x448=((1.32105796835966)*r22*sj4);
IkReal x449=((1.67126837252581)*cj1*cj4);
IkReal x450=((1.32105796835966)*cj4*sj1);
IkReal x451=((1.67126837252581)*r22*sj4);
IkReal x452=((1.32105796835966)*cj1*cj4);
if( IKabs(((-1.36451332423389)+((cj1*x446))+((sj4*x434*x437))+((x434*x438))+(((-1.0)*sj4*x436*x437))+(((-1.0)*x434*x442))+(((-1.0)*x434*x449))+((cj1*x451))+(((-1.0)*x436*x438))+(((6.70821388063278)*x444))+(((-1.0)*cj1*x434*x440))+(((-1.0)*x436*x450))+(((-9.47815609529019)*cj1*x439))+((x434*x450))+((x437*x439))+((x436*x442))+((x436*x449))+(((-1.0)*sj1*x448))+(((-1.0)*sj1*x441))+(((-4.25997933161679)*x433))+((cj1*x436*x440)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.46325046873674)+((sj4*x436*x445))+((x434*x443))+((sj1*x446))+(((-1.0)*x435*x436))+((cj1*x441))+((cj1*x448))+((x434*x435))+(((-1.0)*x434*x447))+(((-9.47815609529019)*sj1*x439))+(((-1.0)*x439*x445))+(((-6.70821388063278)*x433))+((sj1*x436*x440))+(((-1.0)*x436*x443))+((sj1*x451))+(((-1.0)*sj4*x434*x445))+(((-1.0)*sj1*x434*x440))+((x436*x452))+(((-1.0)*x434*x452))+((x436*x447))+(((-4.2599793316168)*x444)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.36451332423389)+((cj1*x446))+((sj4*x434*x437))+((x434*x438))+(((-1.0)*sj4*x436*x437))+(((-1.0)*x434*x442))+(((-1.0)*x434*x449))+((cj1*x451))+(((-1.0)*x436*x438))+(((6.70821388063278)*x444))+(((-1.0)*cj1*x434*x440))+(((-1.0)*x436*x450))+(((-9.47815609529019)*cj1*x439))+((x434*x450))+((x437*x439))+((x436*x442))+((x436*x449))+(((-1.0)*sj1*x448))+(((-1.0)*sj1*x441))+(((-4.25997933161679)*x433))+((cj1*x436*x440))))+IKsqr(((1.46325046873674)+((sj4*x436*x445))+((x434*x443))+((sj1*x446))+(((-1.0)*x435*x436))+((cj1*x441))+((cj1*x448))+((x434*x435))+(((-1.0)*x434*x447))+(((-9.47815609529019)*sj1*x439))+(((-1.0)*x439*x445))+(((-6.70821388063278)*x433))+((sj1*x436*x440))+(((-1.0)*x436*x443))+((sj1*x451))+(((-1.0)*sj4*x434*x445))+(((-1.0)*sj1*x434*x440))+((x436*x452))+(((-1.0)*x434*x452))+((x436*x447))+(((-4.2599793316168)*x444))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.36451332423389)+((cj1*x446))+((sj4*x434*x437))+((x434*x438))+(((-1.0)*sj4*x436*x437))+(((-1.0)*x434*x442))+(((-1.0)*x434*x449))+((cj1*x451))+(((-1.0)*x436*x438))+(((6.70821388063278)*x444))+(((-1.0)*cj1*x434*x440))+(((-1.0)*x436*x450))+(((-9.47815609529019)*cj1*x439))+((x434*x450))+((x437*x439))+((x436*x442))+((x436*x449))+(((-1.0)*sj1*x448))+(((-1.0)*sj1*x441))+(((-4.25997933161679)*x433))+((cj1*x436*x440))), ((1.46325046873674)+((sj4*x436*x445))+((x434*x443))+((sj1*x446))+(((-1.0)*x435*x436))+((cj1*x441))+((cj1*x448))+((x434*x435))+(((-1.0)*x434*x447))+(((-9.47815609529019)*sj1*x439))+(((-1.0)*x439*x445))+(((-6.70821388063278)*x433))+((sj1*x436*x440))+(((-1.0)*x436*x443))+((sj1*x451))+(((-1.0)*sj4*x434*x445))+(((-1.0)*sj1*x434*x440))+((x436*x452))+(((-1.0)*x434*x452))+((x436*x447))+(((-4.2599793316168)*x444))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x453=IKsin(j2);
IkReal x454=IKcos(j2);
IkReal x455=(cj5*r00);
IkReal x456=((0.984807509129517)*sj4);
IkReal x457=(sj0*sj1);
IkReal x458=((0.173649560788721)*cj4);
IkReal x459=(r11*sj5);
IkReal x460=(cj5*sj3);
IkReal x461=((0.984807509129517)*cj4);
IkReal x462=((0.682001083530082)*cj1);
IkReal x463=(r21*sj5);
IkReal x464=((0.173649560788721)*sj4);
IkReal x465=(r01*sj5);
IkReal x466=(cj0*sj1);
IkReal x467=(cj5*r10);
IkReal x468=((0.731351161935082)*cj1);
IkReal x469=(cj3*r02);
IkReal x470=(sj3*sj5);
IkReal x471=(cj3*r12);
IkReal x472=(cj5*r20);
IkReal x473=(cj3*r22);
IkReal x474=((0.027362)*cj1);
IkReal x475=((0.104040710214349)*cj1);
IkReal x476=((0.13162174)*x454);
IkReal x477=(cj3*x472);
IkReal x478=(sj0*x453);
IkReal x479=((0.731351161935082)*x453);
IkReal x480=(cj0*x454);
IkReal x481=((0.682001083530082)*x453);
IkReal x482=(sj0*x454);
IkReal x483=(sj1*x454);
IkReal x484=((0.731351161935082)*x454);
IkReal x485=((0.104040710214349)*x453);
IkReal x486=((0.682001083530082)*x454);
IkReal x487=(cj0*cj1*x453);
evalcond[0]=((((0.000156479204217649)*x472))+(((0.105175)*cj1))+((cj1*x476))+(((-0.13162174)*sj1*x453))+(((-1.0)*x453*x475))+(((-0.104040710214349)*x483))+(((-1.0)*pz))+(((-0.027362)*sj1))+(((-0.000156479204217649)*x463)));
evalcond[1]=((((0.105175)*x466))+((x475*x480))+(((0.000156479204217649)*x455))+(((-1.0)*x466*x485))+((x466*x476))+(((0.13162174)*x487))+(((-1.0)*px))+((cj0*x474))+(((-0.000156479204217649)*x465)));
evalcond[2]=((((0.105175)*x457))+((x475*x482))+(((0.000156479204217649)*x467))+(((-1.0)*x457*x485))+(((-1.0)*py))+(((0.13162174)*cj1*x478))+(((-0.000156479204217649)*x459))+((sj0*x474))+((x457*x476)));
evalcond[3]=(((r22*x464))+((x454*x468))+(((-1.0)*x456*x463))+(((-1.0)*sj1*x479))+(((-0.682001083530082)*x483))+(((-1.0)*x453*x462))+((x458*x472))+(((-1.0)*r22*x461))+(((-1.0)*x458*x463))+((x456*x472)));
evalcond[4]=(((x455*x456))+((x455*x458))+((cj0*x453*x468))+(((-1.0)*x456*x465))+(((-1.0)*x466*x481))+((x462*x480))+((r02*x464))+(((-1.0)*r02*x461))+(((-1.0)*x458*x465))+((x466*x484)));
evalcond[5]=(((x456*x467))+((x457*x484))+(((-1.0)*x456*x459))+((x462*x482))+(((-1.0)*x457*x481))+((r12*x464))+(((-1.0)*r12*x461))+(((-1.0)*x458*x459))+((x458*x467))+((x468*x478)));
evalcond[6]=(((cj3*x461*x463))+(((-1.0)*x456*x473))+((r20*x470))+(((-1.0)*x454*x462))+((sj1*x481))+(((-0.731351161935082)*x483))+(((-1.0)*x453*x468))+(((-1.0)*cj3*x463*x464))+((x464*x477))+(((-1.0)*x458*x473))+(((-1.0)*x461*x477))+((r21*x460)));
evalcond[7]=(((cj3*x461*x465))+(((-1.0)*cj0*x453*x462))+(((-1.0)*x456*x469))+(((-1.0)*x466*x486))+(((-1.0)*cj3*x464*x465))+(((-1.0)*x458*x469))+((x468*x480))+((r01*x460))+((cj3*x455*x464))+(((-1.0)*x466*x479))+((r00*x470))+(((-1.0)*cj3*x455*x461)));
evalcond[8]=((((-1.0)*x462*x478))+((r10*x470))+(((-1.0)*x456*x471))+(((-1.0)*cj3*x459*x464))+(((-1.0)*cj3*x461*x467))+(((-1.0)*x457*x486))+((cj3*x459*x461))+((cj3*x464*x467))+(((-1.0)*x458*x471))+((r11*x460))+((x468*x482))+(((-1.0)*x457*x479)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x488=((0.984807509129517)*cj5);
IkReal x489=(cj0*cj4);
IkReal x490=(r21*sj5);
IkReal x491=((0.173649560788721)*cj4);
IkReal x492=((1.0)*cj0);
IkReal x493=(cj0*sj4);
CheckValue<IkReal> x494 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r21*x492))+(((-1.0)*r20*sj5*x492)))),IkReal((((r20*x488*x489))+(((0.984807509129517)*r22*x493))+(((0.173649560788721)*r22*x489))+(((0.173649560788721)*x490*x493))+(((-0.173649560788721)*cj5*r20*x493))+(((-0.984807509129517)*x489*x490)))),IKFAST_ATAN2_MAGTHRESH);
if(!x494.valid){
continue;
}
CheckValue<IkReal> x495=IKPowWithIntegerCheck(IKsign((((r02*(((((-0.984807509129517)*cj4))+(((0.173649560788721)*sj4))))))+((r01*(((((-1.0)*sj5*x491))+(((-0.984807509129517)*sj4*sj5))))))+((r00*((((cj5*x491))+((sj4*x488)))))))),-1);
if(!x495.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x494.value)+(((1.5707963267949)*(x495.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x496=IKsin(j3);
IkReal x497=IKcos(j3);
IkReal x498=((0.173649560788721)*sj4);
IkReal x499=((0.984807509129517)*cj4);
IkReal x500=(cj5*x496);
IkReal x501=(sj5*x496);
IkReal x502=((1.0)*x497);
IkReal x503=((0.984807509129517)*sj4*x496);
IkReal x504=((0.173649560788721)*cj4*x496);
evalcond[0]=(((r21*x499*x501))+(((-1.0)*r20*x499*x500))+(((-1.0)*r22*x504))+(((-1.0)*r22*x503))+(((-1.0)*cj5*r21*x502))+(((-1.0)*r20*sj5*x502))+(((-1.0)*r21*x498*x501))+((r20*x498*x500)));
evalcond[1]=(((r10*x498*x500))+((r11*x499*x501))+(((-1.0)*r10*sj5*x502))+cj0+(((-1.0)*r10*x499*x500))+(((-1.0)*r11*x498*x501))+(((-1.0)*r12*x504))+(((-1.0)*r12*x503))+(((-1.0)*cj5*r11*x502)));
evalcond[2]=(((r00*x498*x500))+(((-1.0)*r01*x498*x501))+(((-1.0)*sj0))+((r01*x499*x501))+(((-1.0)*r00*sj5*x502))+(((-1.0)*r00*x499*x500))+(((-1.0)*cj5*r01*x502))+(((-1.0)*r02*x504))+(((-1.0)*r02*x503)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x505=((0.0688516427711342)*cj0);
IkReal x506=((0.164110499907597)*px);
IkReal x507=((0.0481101427077374)*cj0);
IkReal x508=((0.0547034999691992)*px);
IkReal x509=(cj0*pz);
IkReal x510=(r01*sj5);
IkReal x511=((0.110884408669817)*cj0);
IkReal x512=(cj4*r22);
IkReal x513=(cj5*r00);
IkReal x514=((0.332653226009452)*cj0);
IkReal x515=(r21*sj5);
IkReal x516=(cj0*cj4);
IkReal x517=((0.000313992904188461)*cj0);
IkReal x518=(cj5*r20);
IkReal x519=((0.000104664301396154)*cj0);
IkReal x520=((2.56798804293015e-5)*x513);
IkReal x521=((2.00661107498811)*x509);
IkReal x522=((2.56798804293015e-5)*x510);
IkReal x523=((0.668870358329369)*x509);
IkReal x524=((8.55996014310049e-6)*x513);
IkReal x525=((8.55996014310049e-6)*x510);
IkReal x526=(sj4*x518);
IkReal x527=(cj0*r22*sj4);
IkReal x528=(x515*x517);
IkReal x529=((0.0586562206888043)*x527);
IkReal x530=(x512*x514);
IkReal x531=(x517*x518);
IkReal x532=(x515*x519);
IkReal x533=((0.0195520735629348)*x527);
IkReal x534=(x518*x519);
IkReal x535=(x511*x512);
IkReal x536=(x516*x518);
IkReal x537=((3.30872245021211e-24)*(x515*x515));
IkReal x538=((3.30872245021211e-24)*(x518*x518));
IkReal x539=(x514*x526);
IkReal x540=((0.0586562206888043)*x536);
IkReal x541=(sj4*x514*x515);
IkReal x542=((0.0586562206888043)*x515*x516);
IkReal x543=((0.0195520735629348)*x536);
IkReal x544=(x511*x526);
IkReal x545=((0.0195520735629348)*x515*x516);
IkReal x546=(sj4*x511*x515);
IkReal x547=(x505+x537+x538);
IkReal x548=(x508+x545+x546+x535+x534+x525);
IkReal x549=(x506+x541+x542+x531+x530+x522);
IkReal x550=(x544+x543+x533+x532+x523+x524);
IkReal x551=(x540+x539+x520+x521+x528+x529);
op[0]=((((-1.0)*x548))+x550+x547);
op[1]=x507;
op[2]=((((-1.0)*x549))+x551+x547);
op[3]=((0.0962202854154749)*cj0);
op[4]=((((-1.0)*x547))+(((-1.0)*x549))+x551);
op[5]=x507;
op[6]=((((-1.0)*x547))+(((-1.0)*x548))+x550);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x552=((0.0688516427711342)*sj0);
IkReal x553=((0.164110499907597)*py);
IkReal x554=((0.0547034999691992)*py);
IkReal x555=(sj0*sj4);
IkReal x556=(cj5*r20);
IkReal x557=(r21*sj5);
IkReal x558=((0.000313992904188461)*sj0);
IkReal x559=(cj4*sj0);
IkReal x560=((0.000104664301396154)*sj0);
IkReal x561=(r11*sj5);
IkReal x562=(pz*sj0);
IkReal x563=((0.0481101427077374)*sj0);
IkReal x564=(cj5*r10);
IkReal x565=((2.56798804293015e-5)*x564);
IkReal x566=((2.00661107498811)*x562);
IkReal x567=((2.56798804293015e-5)*x561);
IkReal x568=((0.668870358329369)*x562);
IkReal x569=((8.55996014310049e-6)*x564);
IkReal x570=((8.55996014310049e-6)*x561);
IkReal x571=((0.0586562206888043)*x559);
IkReal x572=((0.0586562206888043)*r22*x555);
IkReal x573=(x557*x558);
IkReal x574=(x556*x558);
IkReal x575=((0.332653226009452)*r22*x559);
IkReal x576=((0.0195520735629348)*r22*x555);
IkReal x577=(x557*x560);
IkReal x578=(x556*x560);
IkReal x579=((0.110884408669817)*r22*x559);
IkReal x580=((3.30872245021211e-24)*(x557*x557));
IkReal x581=(x556*x571);
IkReal x582=((3.30872245021211e-24)*(x556*x556));
IkReal x583=((0.332653226009452)*x555*x556);
IkReal x584=((0.332653226009452)*x555*x557);
IkReal x585=(x557*x571);
IkReal x586=((0.110884408669817)*x555*x556);
IkReal x587=((0.0195520735629348)*x556*x559);
IkReal x588=((0.0195520735629348)*x557*x559);
IkReal x589=((0.110884408669817)*x555*x557);
IkReal x590=(x552+x580+x582);
IkReal x591=(x553+x575+x574+x567+x584+x585);
IkReal x592=(x554+x579+x578+x570+x588+x589);
IkReal x593=(x577+x576+x568+x569+x586+x587);
IkReal x594=(x573+x572+x566+x565+x581+x583);
j1evalpoly[0]=(((htj1*x563))+((x563*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x590))+(((-1.0)*x592))+x593+(((0.0962202854154749)*sj0*(htj1*htj1*htj1)))+(((htj1*htj1)*(((((-1.0)*x590))+(((-1.0)*x591))+x594))))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x591))+x594+x590))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x592))+x593+x590)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x595=cj1*cj1;
IkReal x596=(r21*sj5);
IkReal x597=((0.0083681115751417)*sj1);
IkReal x598=(cj5*r20);
IkReal x599=((7.49203050861088)*sj1);
IkReal x600=((0.0083681115751417)*cj1);
IkReal x601=(cj4*r22);
IkReal x602=((9.47815609529019)*sj4);
IkReal x603=((49.8689176315288)*pz);
IkReal x604=((0.00780344854617712)*sj1);
IkReal x605=((0.00780344854617712)*cj1);
IkReal x606=(cj1*sj1);
IkReal x607=((7.49203050861088)*cj1);
IkReal x608=((53.4774676097046)*pz);
IkReal x609=((1.67126837252581)*cj4*sj1);
IkReal x610=((1.32105796835966)*r22*sj4);
IkReal x611=((1.67126837252581)*cj1*cj4);
IkReal x612=((1.32105796835966)*cj4*sj1);
IkReal x613=((1.67126837252581)*r22*sj4);
IkReal x614=((1.32105796835966)*cj1*cj4);
if( IKabs(((-1.36451332423389)+(((-4.25997933161679)*x595))+((x598*x611))+((cj1*x598*x602))+((sj4*x596*x599))+(((-1.0)*sj1*x610))+(((-1.0)*sj1*x603))+(((-1.0)*x596*x604))+(((-1.0)*sj4*x598*x599))+(((-1.0)*x596*x611))+(((-1.0)*cj1*x596*x602))+(((-1.0)*x598*x600))+(((-1.0)*x598*x612))+(((6.70821388063278)*x606))+((cj1*x608))+((x596*x600))+((cj1*x613))+((x596*x612))+((x599*x601))+(((-9.47815609529019)*cj1*x601))+((x598*x604)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((1.46325046873674)+((sj1*x598*x602))+((sj1*x608))+(((-1.0)*x597*x598))+((x598*x614))+((sj1*x613))+(((-1.0)*sj4*x596*x607))+(((-1.0)*x596*x609))+(((-1.0)*x596*x614))+(((-4.2599793316168)*x606))+((sj4*x598*x607))+(((-1.0)*x598*x605))+((cj1*x603))+((x596*x605))+(((-9.47815609529019)*sj1*x601))+((cj1*x610))+((x596*x597))+(((-6.70821388063278)*x595))+(((-1.0)*sj1*x596*x602))+((x598*x609))+(((-1.0)*x601*x607)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.36451332423389)+(((-4.25997933161679)*x595))+((x598*x611))+((cj1*x598*x602))+((sj4*x596*x599))+(((-1.0)*sj1*x610))+(((-1.0)*sj1*x603))+(((-1.0)*x596*x604))+(((-1.0)*sj4*x598*x599))+(((-1.0)*x596*x611))+(((-1.0)*cj1*x596*x602))+(((-1.0)*x598*x600))+(((-1.0)*x598*x612))+(((6.70821388063278)*x606))+((cj1*x608))+((x596*x600))+((cj1*x613))+((x596*x612))+((x599*x601))+(((-9.47815609529019)*cj1*x601))+((x598*x604))))+IKsqr(((1.46325046873674)+((sj1*x598*x602))+((sj1*x608))+(((-1.0)*x597*x598))+((x598*x614))+((sj1*x613))+(((-1.0)*sj4*x596*x607))+(((-1.0)*x596*x609))+(((-1.0)*x596*x614))+(((-4.2599793316168)*x606))+((sj4*x598*x607))+(((-1.0)*x598*x605))+((cj1*x603))+((x596*x605))+(((-9.47815609529019)*sj1*x601))+((cj1*x610))+((x596*x597))+(((-6.70821388063278)*x595))+(((-1.0)*sj1*x596*x602))+((x598*x609))+(((-1.0)*x601*x607))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-1.36451332423389)+(((-4.25997933161679)*x595))+((x598*x611))+((cj1*x598*x602))+((sj4*x596*x599))+(((-1.0)*sj1*x610))+(((-1.0)*sj1*x603))+(((-1.0)*x596*x604))+(((-1.0)*sj4*x598*x599))+(((-1.0)*x596*x611))+(((-1.0)*cj1*x596*x602))+(((-1.0)*x598*x600))+(((-1.0)*x598*x612))+(((6.70821388063278)*x606))+((cj1*x608))+((x596*x600))+((cj1*x613))+((x596*x612))+((x599*x601))+(((-9.47815609529019)*cj1*x601))+((x598*x604))), ((1.46325046873674)+((sj1*x598*x602))+((sj1*x608))+(((-1.0)*x597*x598))+((x598*x614))+((sj1*x613))+(((-1.0)*sj4*x596*x607))+(((-1.0)*x596*x609))+(((-1.0)*x596*x614))+(((-4.2599793316168)*x606))+((sj4*x598*x607))+(((-1.0)*x598*x605))+((cj1*x603))+((x596*x605))+(((-9.47815609529019)*sj1*x601))+((cj1*x610))+((x596*x597))+(((-6.70821388063278)*x595))+(((-1.0)*sj1*x596*x602))+((x598*x609))+(((-1.0)*x601*x607))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x615=IKsin(j2);
IkReal x616=IKcos(j2);
IkReal x617=(cj5*r00);
IkReal x618=((0.984807509129517)*sj4);
IkReal x619=(sj0*sj1);
IkReal x620=((0.173649560788721)*cj4);
IkReal x621=(r11*sj5);
IkReal x622=(cj5*sj3);
IkReal x623=((0.984807509129517)*cj4);
IkReal x624=((0.682001083530082)*cj1);
IkReal x625=(r21*sj5);
IkReal x626=((0.173649560788721)*sj4);
IkReal x627=(r01*sj5);
IkReal x628=(cj0*sj1);
IkReal x629=(cj5*r10);
IkReal x630=((0.731351161935082)*cj1);
IkReal x631=(cj3*r02);
IkReal x632=(sj3*sj5);
IkReal x633=(cj3*r12);
IkReal x634=(cj5*r20);
IkReal x635=(cj3*r22);
IkReal x636=((0.027362)*cj1);
IkReal x637=((0.104040710214349)*cj1);
IkReal x638=((0.13162174)*x616);
IkReal x639=(cj3*x634);
IkReal x640=(sj0*x615);
IkReal x641=((0.731351161935082)*x615);
IkReal x642=(cj0*x616);
IkReal x643=((0.682001083530082)*x615);
IkReal x644=(sj0*x616);
IkReal x645=(sj1*x616);
IkReal x646=((0.731351161935082)*x616);
IkReal x647=((0.104040710214349)*x615);
IkReal x648=((0.682001083530082)*x616);
IkReal x649=(cj0*cj1*x615);
evalcond[0]=((((0.105175)*cj1))+(((-0.104040710214349)*x645))+(((-1.0)*pz))+(((-0.027362)*sj1))+(((-0.13162174)*sj1*x615))+(((-0.000156479204217649)*x625))+(((-1.0)*x615*x637))+((cj1*x638))+(((0.000156479204217649)*x634)));
evalcond[1]=(((x628*x638))+(((0.000156479204217649)*x617))+(((0.105175)*x628))+((x637*x642))+(((-1.0)*px))+((cj0*x636))+(((0.13162174)*x649))+(((-1.0)*x628*x647))+(((-0.000156479204217649)*x627)));
evalcond[2]=((((-1.0)*x619*x647))+((x619*x638))+((x637*x644))+(((-1.0)*py))+((sj0*x636))+(((0.13162174)*cj1*x640))+(((-0.000156479204217649)*x621))+(((0.105175)*x619))+(((0.000156479204217649)*x629)));
evalcond[3]=(((x616*x630))+(((-1.0)*sj1*x641))+((r22*x626))+((x618*x634))+(((-1.0)*x620*x625))+(((-0.682001083530082)*x645))+(((-1.0)*x618*x625))+(((-1.0)*x615*x624))+((x620*x634))+(((-1.0)*r22*x623)));
evalcond[4]=(((r02*x626))+((x628*x646))+((x617*x620))+((cj0*x615*x630))+(((-1.0)*r02*x623))+(((-1.0)*x620*x627))+((x617*x618))+(((-1.0)*x628*x643))+(((-1.0)*x618*x627))+((x624*x642)));
evalcond[5]=((((-1.0)*r12*x623))+(((-1.0)*x619*x643))+(((-1.0)*x620*x621))+((x618*x629))+((x630*x640))+(((-1.0)*x618*x621))+((r12*x626))+((x624*x644))+((x619*x646))+((x620*x629)));
evalcond[6]=(((r21*x622))+((sj1*x643))+(((-1.0)*x623*x639))+(((-1.0)*x620*x635))+((cj3*x623*x625))+(((-1.0)*cj3*x625*x626))+(((-1.0)*x618*x635))+(((-0.731351161935082)*x645))+(((-1.0)*x616*x624))+(((-1.0)*x615*x630))+((r20*x632))+((x626*x639)));
evalcond[7]=((((-1.0)*cj3*x617*x623))+((cj3*x617*x626))+(((-1.0)*cj0*x615*x624))+(((-1.0)*x620*x631))+((cj3*x623*x627))+((r01*x622))+(((-1.0)*cj3*x626*x627))+((r00*x632))+((x630*x642))+(((-1.0)*x618*x631))+(((-1.0)*x628*x648))+(((-1.0)*x628*x641)));
evalcond[8]=((((-1.0)*cj3*x623*x629))+(((-1.0)*x619*x648))+(((-1.0)*x619*x641))+((cj3*x621*x623))+(((-1.0)*x620*x633))+((r10*x632))+(((-1.0)*cj3*x621*x626))+((cj3*x626*x629))+(((-1.0)*x624*x640))+((x630*x644))+(((-1.0)*x618*x633))+((r11*x622)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "c5f8882754d4113f739ebe290d01c35f"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
